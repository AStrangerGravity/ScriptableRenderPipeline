#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel MAIN_1 main=MAIN_1 SCATTERING_ORDER=1
#pragma kernel MAIN_N main=MAIN_N

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"

#define TABLE_SIZE uint3(PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_X, \
                         PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Y, \
                         PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Z)

RW_TEXTURE3D(float4, _InScatteredRadianceTable); // Emulate a 4D texture with a "deep" 3D texture

[numthreads(4, 4, 4)]
void main(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint zTexSize = PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Z;
    const uint zTexCnt  = PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_W;

    const float3 scale = rcp(TABLE_SIZE);
    const float3 bias  = 0.5 * scale;

    // Let the hardware and the driver handle the ordering of the computation.
    uint3 tableCoord = dispatchThreadId;
    uint  texId      = dispatchThreadId.z / zTexSize;

    // We don't care about the extremal points.
    float3 uvw = tableCoord * scale + bias;

    // Convention:
    // V points towards the camera.
    // The normal vector N points upwards (local Z).
    // The view vector V spans the local XZ plane.
    // The light vector is represented as {phiL, cosThataL}.
    float cosChi = UnmapAerialPerspective(uvw.xy).x;
    float height = UnmapAerialPerspective(uvw.xy).y;
    float cosHor = GetCosineOfHorizonZenithAngle(height);
    float NdotL  = UnmapCosineOfZenithAngle(frac(uvw.z));
    float phiL   = PI * saturate(texId * rcp(zTexCnt - 1));
    float NdotV  = -cosChi;

    bool aboveHorizon = (cosChi > cosHor);

    float3 N = float3(0, 0, 1);
    float3 V = SphericalToCartesian(0, NdotV);
    float3 L = SphericalToCartesian(phiL, NdotL);

    float LdotV = dot(L, V);
    // float LdotV = SphericalDot(NdotL, phiL, NdotV, 0);

    // Set up the ray...
    float  h = height;
    float  R = _PlanetaryRadius;
    float  r = h + R;
    float2 O = float2(0, r);
    float2 D = float2(SinFromCos(cosChi), cosChi);

    float tMax;

    if (aboveHorizon)
    {
        float _AtmosphericRadius = _PlanetaryRadius + _AtmosphericDepth;
        tMax = IntersectSphere(_AtmosphericRadius, cosChi, r).y; // Max root
    }
    else
    {
        tMax = IntersectSphere(_PlanetaryRadius, cosChi, r).x; // Min root
    }

    float3 radiance = 0;

#if (SCATTERING_ORDER == 1)
    // Integrate in-scattered radiance along -V.
    // Note that we have to evaluate the transmittance integral along -V as well.
    // The transmittance integral is pretty smooth (I plotted it in Mathematica).
    // However, using a non-linear distribution of samples is still a good idea both
    // when looking up (due to the exponential falloff of the coefficients)
    // and for horizontal rays (due to the exponential transmittance term).
    // It's easy enough to use a simple quadratic remap.

    float  t0          = 0;
    float3 viewTransmX = SampleTransmittanceTexture(cosChi, height); // Start to end

    // TODO: we don't have to apply the phase function here.
    // It's a better idea to apply it when sampling the texture.
    // We can even make the single scattering texture 3D instead of 4D!

    float3 inScatterTerm0 = 0;

    if (NdotL > cosHor)
    {
        float3 viewTransm0   = 1;
        float3 lightScatter0 = AtmosphereScatter(LdotV, height);
        float3 lightTransm0  = SampleTransmittanceTexture(NdotL, height);

        inScatterTerm0 = viewTransm0 * lightScatter0 * lightTransm0;
    }

    // const int numSamples = 4096;
    const int numSamples = 256;
    for (int i = 0; i < numSamples; i++)
    {
        float t1 = tMax * Sq((i + 1) * rcp(numSamples));
        float dt = t1 - t0;

        float2 P1      = O + t1 * D;
        float  height1 = length(P1) - R;
        float  cosChi1 = dot(normalize(P1), D);

        // TODO: perform an early termination of the loop if the ray enters planet's shadow
        // (light becomes occluded by the planet).
        float NdotL1  = dot(normalize(P1), L.xy);
        float cosHor1 = GetCosineOfHorizonZenithAngle(height1);

        float3 inScatterTerm1 = 0;

        if (NdotL1 > cosHor)
        {
            float3 viewTransmB   = SampleTransmittanceTexture(cosChi1, height1);
            float3 viewTransm1   = viewTransmX * rcp(viewTransmB);
            float3 lightScatter1 = AtmosphereScatter(LdotV, height1);
            float3 lightTransm1  = SampleTransmittanceTexture(NdotL1, height1);

            inScatterTerm1 = viewTransm1 * lightScatter1 * lightTransm1;
        }

        // Compute the amount of in-scattered radiance.
        // Evaluate the transmittance integral from 't0' to 't1' using the trapezoid rule.
        // Integral{a, b}{Transmittance(0, t) dt} â‰ˆ
        // (Transmittance(0, a) + Transmittance(0, b)) * (b - a) / 2 =
        // (Transmittance(0, a) + Transmittance(0, tMax) / Transmittance(b, tMax)) * (b - a) / 2.
        // We handle other terms in a similar way (by pre-multiplying transmittance).
        radiance += (inScatterTerm0 + inScatterTerm1) * _SunRadiance * (0.5 * dt);

        // Carry these over to the next iteration...
        t0             = t1;
        inScatterTerm0 = inScatterTerm1;
    }
#endif

    // if (NdotL > cosHor)
    // {
    //     // Sun is directly visible from this position.
    //     float3 transm  = SampleTransmittanceTexture(NdotL, height, false);
    //     float3 scatter = AtmosphereScatter(LdotV, height);

    //     radiance += scatter * transm * _SunRadiance;
    // }
    // else
    // {
    //     // The sun is occluded by the planet.
    // }

    // // Integrate ground contribution.
    // // The ground is a Lambertian reflector. It is basically a textured sphere light.
    // // TODO: a lot of values are almost zero! How to early-out?
    // {
    //     // We will importance sample according to the solid angle.
    //     // Hard to take transmittance, the phase function and the illumination into account...
    //     float R = _PlanetaryRadius;
    //     float h = height;
    //     float r = R + h;

    //     float3 P           = r * N;
    //     float  cosAperture = -cosHor; // Cosine of the half-angle

    //     const int numGroundSamples = 89;

    //     for (int i = 0; i < numGroundSamples; i++)
    //     {
    //         float2 f = Fibonacci2d(i, numGroundSamples);

    //         // Construct a direction around the up vector.
    //         float3 dir; float rcpPdf;
    //         SampleCone(f, cosAperture, dir, rcpPdf);

    //         // Flip it upside-down to point towards the sphere light (planet).
    //         float3 gL = -dir;

    //         // TODO: compute analytically?
    //         float  t  = IntersectPlanetFromOutside(gL.z, h);
    //         float3 gP = P + t * gL;
    //         float3 gN = normalize(gP);

    //         // Shade the ground.
    //         const float3 gBrdf = INV_PI * _GroundAlbedo;

    //         float3 transm  = SampleTransmittanceTexture(gL.z, h, true);
    //         float3 scatter = AtmosphereScatter(dot(gL, V), h);

    //         float weight = rcpPdf * rcp(numGroundSamples);
    //         radiance += weight * scatter * transm * gBrdf * SampleGroundIrradianceTexture(dot(gN, L));
    //     }
    // }

    // if (!aboveHorizon) radiance = 0;

    // TODO: deep compositing.
    float4 tableEntry = float4(radiance, tMax);
    // float4 tableEntry = float4(radiance, tMax);
    // float4 tableEntry = float4(cosChi, h, NdotL, tMax);
    // float4 tableEntry = float4(viewTransmX, tMax);

    _InScatteredRadianceTable[tableCoord] = tableEntry;
}
