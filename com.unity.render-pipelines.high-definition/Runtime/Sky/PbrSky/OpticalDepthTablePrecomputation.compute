#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch
#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyRenderer.cs.hlsl"

#define TABLE_SIZE float2(PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_X, PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_Y)

CBUFFER_START(UnityPbrSky)
    // All the entries use km and 1/km units.
    float _PlanetaryRadius;
    float _AtmosphericLayerHeight;
    float _AirDensityFalloff;
    float _AirScaleHeight;
    float _AerosolDensityFalloff;
    float _AerosolScaleHeight;
CBUFFER_END

RWTexture2D<float2> _OpticalDepthTable; // of TABLE_SIZE

#define sec(x) rcp(cos(x))

// For (chi == Pi/2).
float ChapmanHorizontal(float x)
{
    float r = rsqrt(x);
    float s = x * r; // sqrt(x)

    return 1.2534 * s + 0.467 * r;
}

// For (chi < Pi/2).
float ChapmanUpper(float x, float chi)
{
    float a = 3.88 * pow(abs(x), -1.143);
    float b = 1.0123 - 1.454 * rsqrt(x);
    float c = sec(b * chi) - 0.834;
    float d = a * c;

    return sec(chi - d);
}

// Requirements: (x > 0).
// We use the following approximation:
// "An approximate form for the Chapman grazing incidence function" by Titheridge, J. E.
// TODO: consider Christian Schueler's cheaper approximation.
float ChapmanFunction(float x, float chi)
{
    bool useIdentity = chi > HALF_PI;

    if (useIdentity)
    {
        chi = PI - chi;
    }

    float cu = ChapmanUpper(x, chi);

    if (useIdentity)
    {
        float z = x * sin(chi);
        float a = exp(x - z);
        float r = rsqrt(z);
        float s = z * r; // sqrt(z)
        float b = 2.507 * s + 0.934 * r;

        return a * b - cu;
    }
    else
    {
        return cu;
    }
}

[numthreads(8, 8, 1)]
void main(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    const float2 scale = rcp(TABLE_SIZE);
    const float2 bias  = 0.5 * scale;

    // Let the hardware and the driver handle the ordering of the computation.
    uint2 tableCoord = dispatchThreadId;

    // We don't care about the extremal points (boundary values).
    float2 coordNDC = tableCoord * scale + bias;

    // Height is the altitude.
    // A uniform distribution results in a rather non-linear (but rather exponential) LUT.
    // The cause is the exp(-h * N) term (and not the Chapman function).
    // Unfortunately, if we drop this term, we will have to use FP32 instead of FP16.
    // The quadratic remap doesn't appear to look much better (and creates some artifacts in the LUT).
    float height = coordNDC.y * _AtmosphericLayerHeight;

    // Parametrization in terms of neither the angle nor the cosine results in a linear LUT.
    // However, at least the cosine offers more resolution near the horizon,
    // where the function changes more rapidly.
    float cosChi = 1 - 2 * coordNDC.x;
    float sinChi = sqrt(1 - cosChi * cosChi);

    float h = height;
    float R = _PlanetaryRadius;
    float r = R + h;

    float2 H = float2(_AirScaleHeight,    _AerosolScaleHeight);
    float2 N = float2(_AirDensityFalloff, _AerosolDensityFalloff);

    // Ray origin is within a slice (atmosphere) between two spheres (the planet and the outer space).
    // We need to determine the location where the ray exits the slice.
    // The ray always intersects the outer sphere, but does not necessarily intersect the inner sphere.
    // Therefore, if we intersect the inner sphere, we are done.
    // We assume the outer sphere to be infinite (for simplicity).
    float tHit = FLT_INF;

    float2 rayOrigin    = float2(0, r);
    float2 rayDirection = float2(sinChi, cosChi);

    // Solve: t^2 + 2 * b * t + c = 0.
    float b = dot(rayOrigin, rayDirection);
    float c = dot(rayOrigin, rayOrigin) - R * R;
    float d = b * b - c;

    bool intersectsPlanet = false;

    if (d >= 0)
    {
        // We always take the closest intersection.
        float t = -b - sqrt(d);

        if (t > 0)
        {
            intersectsPlanet = true;
            tHit = t;
        }
    }

    float2 tableEntry;

    if (!intersectsPlanet)
    {
        // Now we need to compute the optical depth along the ray.
        // It is given as the integral of the atmospheric thickness (extinction) along the ray.
        //
        // AirThickness[h]         = AirThickness[0]     * Exp[-h / airH]
        // AerosolThickness[h]     = AerosolThickness[0] * Exp[-h / aerosolH]
        // AtmosphericThickness[h] = AirThickness[h] + AerosolThickness[h]
        //
        // For now, assume that no intersection with the planet occurred.
        //
        // OpticalDepth = Integrate[Extinction[t], {t, 0, Infinity}]
        // OpticalDepth = Integrate[Thickness[0] * Exp[-h[t] / H], {t, 0, Infinity}]
        // OpticalDepth = Thickness[0] * Integrate[Exp[-h[t] / H], {t, 0, Infinity}]
        // OpticalDepth = Thickness[0] * Integrate[Exp[(R - Sqrt[(r * Sin[chi])^2 + t^2]) / H], {t, r * Cos[chi], Infinity}]
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * Integrate[Exp[(r - Sqrt[(r * Sin[chi])^2 + t^2]) / H] / H, {t, r * Cos[chi], Infinity}]
        // By defining (x = r / H) and (s = t / H), we get:
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * Integrate[Exp[x - Sqrt[(x * Sin[chi])^2 + s^2]], {s, x * Cos[chi], Infinity}]
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * Integrate[Exp[x - Sqrt[s^2 + 2 * s * (x * Cos[chi]) + x^2]], {s, 0, Infinity}]
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * ChapmanFunction[x, chi]
        //
        // For more information, see the article by Christian Schueler titled
        // "Approximation to the Chapman Grazing-Incidence Function for Atmospheric Scattering".
        //
        // To save on the storage, we will scale by sea level thickness at runtime.

        float chi = acos(cosChi);

        tableEntry.x = H.x * exp(-h * N.x) * ChapmanFunction(r * N.x, chi);
        tableEntry.y = H.y * exp(-h * N.y) * ChapmanFunction(r * N.y, chi);
    }
    else
    {
        // The Chapman function is defined as an integral to infinity.
        // In this case, the integration range is bounded.
        // We can still use the Chapman function by utilizing a small trick.
        // We compute the intersection point with the planet,
        // and evaluate the Chapman function at that point in the opposite direction.
        //
        // We must determine the new angle of the Chapman function.
        // Using the Law of Cosines,
        // cos(C) = (a^2 + b^2 - c^2) / (2 * a * b).

        float cosC = (R * R + tHit * tHit - r * r) / (2 * R * tHit);
        float chi  = PI - acos(cosC);

        tableEntry.x = H.x * ChapmanFunction(R * N.x, chi);
        tableEntry.y = H.y * ChapmanFunction(R * N.y, chi);
    }

    _OpticalDepthTable[tableCoord] = tableEntry;
}
