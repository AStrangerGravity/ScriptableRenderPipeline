#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch
#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyRenderer.cs.hlsl"

#define TABLE_SIZE float2(PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_X, PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_Y)

CBUFFER_START(UnityPbrSky)
    // All of the entries use metric units (no km, etc).
    float planetaryRadius;
    float atmosphericLayerHeight;
    float airDensityFalloff;
    float airScaleHeight;
    float aerosolDensityFalloff;
    float aerosolScaleHeight;
CBUFFER_END

RWTexture2D<float2> opticalDepthTable; // of TABLE_SIZE

#define sec(x) rcp(cos(x))

// For (chi == Pi/2).
float ChapmanHorizontal(float x)
{
    float r = rsqrt(x);
    float s = x * r; // sqrt(x)

    return 1.2534 * s + 0.467 * r;
}

// For (chi < Pi/2).
float ChapmanUpper(float x, float chi)
{
    float a = 3.88 * pow(abs(x), -1.143);
    float b = 1.0123 - 1.454 * rsqrt(x);
    float c = sec(b * chi) - 0.834;
    float d = DegToRad(a * c);

    return sec(chi - d);
}

// Requirements: (x > 0).
// We use the following approximation:
// "An approximate form for the Chapman grazing incidence function" by Titheridge, J. E.
// TODO: consider Christian Schueler's cheaper approximation.
float ChapmanFunction(float x, float chi)
{
    bool useIdentity = chi > HALF_PI;

    if (useIdentity)
    {
        chi = PI - chi;
    }

    float cu = ChapmanUpper(x, chi);

    if (useIdentity)
    {
        float z = x * sin(chi);
        float r = rsqrt(z);
        float s = z * r; // sqrt(z)
        float a = 0.934 * r;
        float b = 2.507 * s + a;
        float c = exp(x - z);

        return c * b - cu;
    }
    else
    {
        return cu;
    }
}

[numthreads(8, 8, 1)]
void main(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    const float2 scale = rcp(TABLE_SIZE);
    const float2 bias  = 0.5 * scale;

    // Let the hardware and the driver handle the ordering of the computation.
    uint2 tableCoord = dispatchThreadId;

    // We don't care about the extremal points (boundary values).
    float2 coordNDC = tableCoord * scale + bias;

    // Height is the altitude.
    float height = coordNDC.x * atmosphericLayerHeight; // TODO: does a uniform distribution make sense?
    float zenith = coordNDC.y * PI;                     // TODO: does an equiangular distribution make sense?
    float cosChi = cos(zenith);
    float sinChi = sin(zenith);

    // Ray origin is within a slice (atmosphere) between two spheres (the planet and the outer space).
    // We need to determine the location where the ray exits the slice.
    // The ray always intersects the outer sphere, but does not necessarily intersect the inner sphere.
    // Therefore, if we intersect the inner sphere, we are done.
    // We assume the outer sphere to be infinite (for simplicity).
    float tHit = FLT_INF;

    float h = height;
    float R = planetaryRadius;
    float r = R + h;

    float2 rayOrigin    = float2(0, r);
    float2 rayDirection = float2(sinChi, cosChi);

    // Solve: t^2 + 2 * b * t + c = 0.
    float b = dot(rayOrigin, rayDirection);
    float c = dot(rayOrigin, rayOrigin) - R * R;
    float d = b * b - c;

    bool intersectsPlanet = (d >= 0);

    if (intersectsPlanet)
    {
        // We always take the closest intersection.
        tHit = -b - sqrt(d);
    }

    float airH     = airScaleHeight;
    float aerosolH = aerosolScaleHeight;
    float airN     = airDensityFalloff;     // = (1 / airH)
    float aerosolN = aerosolDensityFalloff; // = (1 / aerosolH)

    // Now we need to compute the optical depth along the ray.
    // It is given as the integral of the atmospheric thickness (extinction) along the ray.
    //
    // AirThickness[h]         = AirThickness[0]     * Exp[-h / airH]
    // AerosolThickness[h]     = AerosolThickness[0] * Exp[-h / aerosolH]
    // AtmosphericThickness[h] = AirThickness[h] + AerosolThickness[h]
    //
    // For now, assume that no intersection with the planet occurred.
    //
    // OpticalDepth = Integrate[Extinction[t], {t, 0, Inf}]
    // OpticalDepth = Integrate[Thickness[0] * Exp[-h[t] / H], {t, 0, Inf}]
    // OpticalDepth = Thickness[0] * Integrate[Exp[-h[t] / H], {t, 0, Inf}]
    // OpticalDepth = Thickness[0] * Integrate[Exp[(R - Sqrt[(r * Sin[chi])^2 + t^2]) / H], {t, r * Cos[chi], Inf}]
    // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * Integrate[Exp[(r - Sqrt[(r * Sin[chi])^2 + t^2]) / H] / H, {t, r * Cos[chi], Inf}]
    // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * ChapmanFunction[r / H, chi]
    //
    // For more information, see "Approximation to the Chapman Grazing-Incidence Function for Atmospheric Scattering"
    // by Christian Schueler.
    //
    // To save on the storage, we will scale by sea level thickness at runtime.
    // Therefore, we compute and store:
    //
    // X = airH     * Exp[-h * airN]     * ChapmanFunction[r * airN, chi]
    // Y = aerosolH * Exp[-h * aerosolN] * ChapmanFunction[r * airN, chi]

    float2 tableEntry;
    tableEntry.x = airH     * exp(-h * airN)     * ChapmanFunction(r * airN,     zenith);
    tableEntry.y = aerosolH * exp(-h * aerosolN) * ChapmanFunction(r * aerosolN, zenith);

    if (intersectsPlanet)
    {
        // We must reduce the optical depth to account for the shorter unoccluded distance
        // along the ray. Therefore, we have to evaluate the Chapman function again.
        // In this case, the starting position is (h = 0, r = R).
        // We must determine the new angle of the Chapman function.
        // Using the Law of Cosines,
        // cos(C) = (a^2 + b^2 - c^2) / (2 * a * b).
        float cosC = (R * R + tHit * tHit - r * r) / (2 * R * tHit);
        float chi  = acos(cosC);

        tableEntry.x -= airH     * ChapmanFunction(R * airDensityFalloff,     chi);
        tableEntry.y -= aerosolH * ChapmanFunction(R * aerosolDensityFalloff, chi);
    }

    opticalDepthTable[tableCoord] = tableEntry;
}
