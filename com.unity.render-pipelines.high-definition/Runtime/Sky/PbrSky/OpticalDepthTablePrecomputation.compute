#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch
#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyRenderer.cs.hlsl"

#define TABLE_SIZE float2(PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_X, PBRSKYCONFIG_OPTICAL_DEPTH_TABLE_SIZE_Y)
#define N_SAMPLES  4096

CBUFFER_START(UnityPbrSky)
    // All the entries use km and 1/km units.
    float _PlanetaryRadius;
    float _AtmosphericLayerHeight;
    float _AirDensityFalloff;
    float _AirScaleHeight;
    float _AerosolDensityFalloff;
    float _AerosolScaleHeight;
CBUFFER_END

RWTexture2D<float2> _OpticalDepthTable; // of TABLE_SIZE

#define sec(x) rcp(cos(x))

// For (chi == Pi/2).
float ChapmanHorizontal(float x)
{
    float r = rsqrt(x);
    float s = x * r; // sqrt(x)

    return 1.2534 * s + 0.467 * r;
}

// For (chi < Pi/2).
float ChapmanUpper(float x, float chi)
{
    float a = 3.88 * pow(abs(x), -1.143);
    float b = 1.0123 - 1.454 * rsqrt(x);
    float c = sec(b * chi) - 0.834;
    float d = DegToRad(a * c);

    return sec(chi - d);
}

// Requirements: (x > 0).
// We use the following approximation:
// "An approximate form for the Chapman grazing incidence function" by Titheridge, J. E.
// TODO: consider Christian Schueler's cheaper approximation.
float ChapmanFunction(float x, float chi)
{
    bool useIdentity = chi > HALF_PI;

    if (useIdentity)
    {
        chi = PI - chi;
    }

    float cu = ChapmanUpper(x, chi);

    if (useIdentity)
    {
        float z = x * sin(chi);
        float r = rsqrt(z);
        float s = z * r; // sqrt(z)
        float a = 0.934 * r;
        float b = 2.507 * s + a;
        float c = exp(x - z);

        return c * b - cu;
    }
    else
    {
        return cu;
    }
}

[numthreads(8, 8, 1)]
void main(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    const float2 scale = rcp(TABLE_SIZE);
    const float2 bias  = 0.5 * scale;

    // Let the hardware and the driver handle the ordering of the computation.
    uint2 tableCoord = dispatchThreadId;

    // We don't care about the extremal points (boundary values).
    float2 coordNDC = tableCoord * scale + bias;

    // Height is the altitude.
    float zenith = coordNDC.x * PI;                      // TODO: does an equiangular distribution make sense?
    float height = coordNDC.y * _AtmosphericLayerHeight; // TODO: does a uniform distribution make sense?
    float cosChi = cos(zenith);
    float sinChi = sin(zenith);

    // Ray origin is within a slice (atmosphere) between two spheres (the planet and the outer space).
    // We need to determine the location where the ray exits the slice.
    // The ray always intersects the outer sphere, but does not necessarily intersect the inner sphere.
    // Therefore, if we intersect the inner sphere, we are done.
    // We assume the outer sphere to be infinite (for simplicity).
    float tHit = FLT_INF;

    float h = height;
    float R = _PlanetaryRadius;
    float r = R + h;

    float2 H = float2(_AirScaleHeight,    _AerosolScaleHeight);
    float2 N = float2(_AirDensityFalloff, _AerosolDensityFalloff);
    float2 X = r * N;

    float2 rayOrigin    = float2(0, r);
    float2 rayDirection = float2(sinChi, cosChi);

    // Solve: t^2 + 2 * b * t + c = 0.
    float b = dot(rayOrigin, rayDirection);
    float c = dot(rayOrigin, rayOrigin) - R * R;
    float d = b * b - c;

    bool intersectsPlanet = false;

    if (d >= 0)
    {
        // We always take the closest intersection.
        float t = -b - sqrt(d);

        if (t > 0)
        {
            intersectsPlanet = true;
            tHit = t;
        }
    }

    float2 tableEntry;

    if (intersectsPlanet)
    {
        // The Chapman function is defined as an integral to infinity.
        // In this case, the integration range is bounded.
        // Solving this analytically is too complicated, so we perform numerical integration instead.
        // We use the midpoint rule.
        // Integrate[Exp[x - Sqrt[s^2 + 2*s*(x*Cos[chi]) + x^2]], {s, 0, tHit / H}]

        float2 maxS = tHit * N;
        float2 dS   = maxS * rcp(N_SAMPLES);

        tableEntry = 0;

        for (int i = 0; i < N_SAMPLES; i++)
        {
            float2 S = i * dS + (0.5 * dS);

            // TODO: importance sampling?
            tableEntry += exp(X - sqrt(S * S + S * (2 * X * cosChi) + (X * X))) * dS;
        }
    }
    else
    {
        // Now we need to compute the optical depth along the ray.
        // It is given as the integral of the atmospheric thickness (extinction) along the ray.
        //
        // AirThickness[h]         = AirThickness[0]     * Exp[-h / airH]
        // AerosolThickness[h]     = AerosolThickness[0] * Exp[-h / aerosolH]
        // AtmosphericThickness[h] = AirThickness[h] + AerosolThickness[h]
        //
        // For now, assume that no intersection with the planet occurred.
        //
        // OpticalDepth = Integrate[Extinction[t], {t, 0, Infinity}]
        // OpticalDepth = Integrate[Thickness[0] * Exp[-h[t] / H], {t, 0, Infinity}]
        // OpticalDepth = Thickness[0] * Integrate[Exp[-h[t] / H], {t, 0, Infinity}]
        // OpticalDepth = Thickness[0] * Integrate[Exp[(R - Sqrt[(r * Sin[chi])^2 + t^2]) / H], {t, r * Cos[chi], Infinity}]
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * Integrate[Exp[(r - Sqrt[(r * Sin[chi])^2 + t^2]) / H] / H, {t, r * Cos[chi], Infinity}]
        // By defining (x = r / H) and (s = t / H), we get:
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * Integrate[Exp[x - Sqrt[(x * Sin[chi])^2 + s^2]], {s, x * Cos[chi], Infinity}]
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * Integrate[Exp[x - Sqrt[s^2 + 2 * s * (x * Cos[chi]) + x^2]], {s, 0, Infinity}]
        // OpticalDepth = Thickness[0] * H * Exp[(R - r) / H] * ChapmanFunction[x, chi]
        //
        // For more information, see the article by Christian Schueler titled
        // "Approximation to the Chapman Grazing-Incidence Function for Atmospheric Scattering".
        //
        // To save on the storage, we will scale by sea level thickness at runtime.

        tableEntry.x = ChapmanFunction(X.x, zenith);
        tableEntry.y = ChapmanFunction(X.y, zenith);

    }

    // Shared terms.
    tableEntry *= H * exp(-h * N);

    tableEntry.y = intersectsPlanet ? 1 : 0;

    _OpticalDepthTable[tableCoord] = tableEntry;
}
